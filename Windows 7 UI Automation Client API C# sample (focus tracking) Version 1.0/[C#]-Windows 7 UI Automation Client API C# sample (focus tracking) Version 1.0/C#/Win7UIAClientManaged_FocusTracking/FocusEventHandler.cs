//*******************************************************************************
//   Copyright 2011 Guy Barker
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//*******************************************************************************

// EventHandler.cs : Implement a UIA event handler.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Drawing;
using interop.UIAutomationCore; // Generated by VS 2010 as the interop layer between the C# sample code and the unmanaged Windows 7 UIA API.

namespace Win7UIAClientManaged
{
    class SampleFocusEventHandler : IUIAutomationFocusChangedEventHandler
    {
        private IUIAutomation _automation; // Main UIA object required by any UIA client app.

        private Thread _threadBackground; // Background MTA thread on which the event handler is added and removed.
        private AutoResetEvent _autoEventInit; // Event used to allow background thread to take any required initialization action.
        private AutoResetEvent _autoEventMsg; // Event used to notify the background thread that action is required.

        // SampleEventMsgType and SampleEventMsgData are used to allow the main UI thread that specific action 
        // is required by the background thread. These messages are not related to the UIA API, but simply a 
        // means for the two threads to communicate.
        private enum SampleMsgType
        {
            msgNull,
            msgRegisterEventHandler,
            msgCloseDown
        };

        private struct SampleEventMsgData
        {
            public SampleMsgType msgType;
        };

        // Note that UIAutomationClient.UIA_PropertyIds could be supplied to calls to UIA in this file, 
        // but that would require building thesample using settings other than the VS defaults. So 
        // instead supply a value equal to UIAutomationClient.UIA_PropertyIds;
        private int _propertyIdBoundingRectangle = 30001;
        private int _propertyIdName = 30005;

        // This sample doesn't really need to support a queue of messages for action required by the 
        // backgroung thread, but use a queue anyway in case requirements change in the future.
        private Queue<SampleEventMsgData> _msgQueue = new Queue<SampleEventMsgData>();

        // The event handler should be removed when we close down.
        private bool _fAddedEventHandler = false;

        // When the event handler gets a focus change event from UIA, it invokes a delegate running 
        // on the main UI thread to have that thread respond to the request.
        private Win7UIAClientForm_FocusTracking _formMainUI;
        public delegate void SampleUIEventHandlerDelegate();
        private Win7UIAClientForm_FocusTracking.SampleUIEventHandlerDelegate _sampleUIEventHandlerDelegate;

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // SampleFocusEventHandler() - Constructor.
        //
        // Runs on the main UI thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public SampleFocusEventHandler(Win7UIAClientForm_FocusTracking formMainUI, 
                                       Win7UIAClientForm_FocusTracking.SampleUIEventHandlerDelegate sampleUIEventHandlerDelegate)
        {
            _formMainUI = formMainUI;
            _sampleUIEventHandlerDelegate = sampleUIEventHandlerDelegate;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // Uninitialize()
        //
        // Called on main UI thread to close the background thread down.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public void Uninitialize()
        {
            // Tell the background thread to close down.
            if (_threadBackground != null)
            {
                SampleEventMsgData msgData = new SampleEventMsgData();
                msgData.msgType = SampleMsgType.msgCloseDown;
                AddMsgToQueue(msgData);
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // AddMsgToQueue()
        //
        // Update a list of messages waiting to be processed by the background thread.
        // 
        // Run on the main UI thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        private void AddMsgToQueue(SampleEventMsgData msgData)
        {
            // Request the lock, and block until it is obtained.
            Monitor.Enter(_msgQueue);
            try
            {
                // When the lock is obtained, add an element.
                _msgQueue.Enqueue(msgData);
            }
            finally
            {
                // Ensure that the lock is released.
                Monitor.Exit(_msgQueue);
            }

            _autoEventMsg.Set();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // StartEventHandler()
        //
        // Create the background thread on which the UIA event handler must run.
        //
        // This function runs on the main UI thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public void StartEventHandler()
        {
            // This sample doesn't expect to enter here with a background thread already initialized.
            if (_threadBackground != null)
            {
                return;
            }

            // The main thread will notify the background thread later when it's time to close down.
            _autoEventMsg = new AutoResetEvent(false);

            // Create the background thread, and wait until it's ready to start working.
            _autoEventInit = new AutoResetEvent(false);
            ParameterizedThreadStart paramThreadStart = new ParameterizedThreadStart(s_ThreadProc);

            _threadBackground = new Thread(paramThreadStart);
            _threadBackground.SetApartmentState(ApartmentState.MTA); // The event handler must run on an MTA thread.
            _threadBackground.Start(this);

            _autoEventInit.WaitOne();

            // The background thread is up and running. Have it add the UIA event handler now.
            SampleEventMsgData msgData = new SampleEventMsgData();
            msgData.msgType = SampleMsgType.msgRegisterEventHandler;
            AddMsgToQueue(msgData);
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // s_ThreadProc()
        //
        // Static entry point for the thread on which the event handlers will be added and removed.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public static void s_ThreadProc(object data)
        {
            SampleFocusEventHandler eventHandler = (SampleFocusEventHandler)data;
            eventHandler.ThreadProc();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // ThreadProc()
        //
        // Entry point for the background MTA thread on which the UIA event handler will be added and removed.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        private void ThreadProc()
        {
            // The first step in calling UIA is getting a CUIAutomation object.
            _automation = new CUIAutomation();

            // Let the main thread know this thread is ready to start processing.
            // This event isn't required for this sample, but a shipping app may 
            // have work to do at the start of the background thread before the 
            // main thread is to continue.
            _autoEventInit.Set();

            // fCloseDown will be set true when the thread is to close down.
            bool fCloseDown = false;

            while (!fCloseDown)
            {
                // Wait here until we're told we have some work to do.
                _autoEventMsg.WaitOne();

                while (true)
                {
                    SampleEventMsgData msgData;

                    // Note that none of the queue or message related action here is specific to UIA.
                    // Rather it is only a means for the main UI thread and the background MTA thread
                    // to communicate.

                    // Get a message from the queue of action-related messages.
                    Monitor.Enter(_msgQueue);
                    try
                    {
                        // An exception is thrown when the queue is empty.
                        msgData = _msgQueue.Dequeue();
                    }
                    catch (InvalidOperationException)
                    {
                        // InvalidOperationException is thrown if the queue is empty.
                        msgData.msgType = SampleMsgType.msgNull;

                        break;
                    }
                    finally
                    {
                        // Ensure that the lock is released.
                        Monitor.Exit(_msgQueue);
                    }

                    if (msgData.msgType == SampleMsgType.msgRegisterEventHandler)
                    {
                        // The main thread has requested that the UIA event handler is set up now.
                        RegisterFocusChangedListener();
                    }
                    else if (msgData.msgType == SampleMsgType.msgCloseDown)
                    {
                        // The main UI thread is telling this background thread to close down.
                        fCloseDown = true;

                        break;
                    }                    
                }
            }

            // Remove the UIA event handler now if it was successfully added earlier.
            RemoveSampleFocusEventHandler();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // RegisterFocusChangedListener()
        //
        // Add a UIA event handler to react to focus change events sent from UIA.
        //
        // Runs on the background thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        void RegisterFocusChangedListener()
        {
            // Create a cache request for the properties we know we'll need when a focus change occurs.
            // By setting up this cache request, we won't incur a cross-proc call later to get the
            // properties when we receive the event.
            IUIAutomationCacheRequest cacheRequest = _automation.CreateCacheRequest();
                
            cacheRequest.AddProperty(_propertyIdName);
            cacheRequest.AddProperty(_propertyIdBoundingRectangle);

            // The above properties are all we'll need, so we have have no need for a reference
            // to the source element when we receive the event.
            cacheRequest.AutomationElementMode = AutomationElementMode.AutomationElementMode_None;

            // Now set up the event handler.
            _automation.AddFocusChangedEventHandler(cacheRequest, this);

            _fAddedEventHandler = true;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // RemoveSampleFocusEventHandler()
        //
        // Perform all cleanup of objects that we initialized on startup in the background thread.
        //
        // Runs on the background thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        void RemoveSampleFocusEventHandler()
        {
            // If we successfully added an event handler earlier, remove it now. The
            // handler must be removed on the same thread on which it was added.
            if (_fAddedEventHandler)
            {
                // Depending on the timing of events generated around the time we remove 
                // the event handler, an event can arrive at the handler after a successful 
                // call to remove the event handler. So set the flag here to prevent our 
                // event handler from taking any more action if futher calls to our event 
                // handler are made.
                _fAddedEventHandler = false;

                _automation.RemoveFocusChangedEventHandler(this);
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // HandleFocusChangedEvent()
        //
        // Sample application's handler for UIA FocusChanged events.
        //
        // Runs on a background thread create by UIA.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public void HandleFocusChangedEvent(IUIAutomationElement sender)
        {
            // Check that this event hasn't arrived around the time we're removing the event handler on shutdown.
            if (!_fAddedEventHandler)
            {
                return;
            }

            // Note that in practice when a window opens, many focus changes can occur in rapid succession 
            // and there's no benefit to the user in reacting to all these events. So a shipping app might 
            // choose to ignore focus change events until (say) 100ms has elapsed since receiving an event. 

            // Get the cached bounding rectangle and name of the element sending the Focus Changed event.
            // Because these properties are cached, there are no cross-proc calls required here.

            tagRECT rect = sender.CachedBoundingRectangle;
            Rectangle rectBounds = new Rectangle(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);

            string strName = sender.CachedName;

            // Now have the main thread highlight the focused UI. This will return immediately.
            _formMainUI.BeginInvoke(_sampleUIEventHandlerDelegate, strName, rectBounds);
        }
    }
}
