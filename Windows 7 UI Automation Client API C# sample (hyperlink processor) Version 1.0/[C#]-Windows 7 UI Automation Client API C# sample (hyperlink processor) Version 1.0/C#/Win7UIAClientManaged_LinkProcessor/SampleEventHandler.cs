//*******************************************************************************
//   Copyright 2011 Guy Barker
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//*******************************************************************************

// EventHandler.cs : Implement a UIA event handler.

using System;
using System.Collections.Generic;
using System.Threading;
using interop.UIAutomationCore; // Generated by VS 2010 as the interop layer between the C# sample code and the unmanaged Windows 7 UIA API.

namespace Win7UIAClientManaged
{
    class SampleEventHandler : IUIAutomationStructureChangedEventHandler
    {
        // This sample reacts to changes in an Internet Explorer window.
        private string strBrowserWindowClass = "IEFrame";

        private IUIAutomation _automation; // Main UIA object required by any UIA client app.
        private static IUIAutomationElement _elementBrowser; // UIA element representing the browser window.

        private Thread _threadBackground; // Background MTA thread on which the event handler is added and removed.
        private AutoResetEvent _autoEventInit; // Event used to allow background thread to take any required initialization action.
        private AutoResetEvent _autoEventMsg; // Event used to notify the background thread that action is required.

        // SampleEventMsgType and SampleEventMsgData are used to allow the main UI thread that specific action 
        // is required by the background thread. These messages are not related to the UIA PAI, but simply a 
        // means for the two threads to communicate.
        private enum SampleMsgType
        {
            msgNull,
            msgRegisterEventHandler,
            msgCloseDown
        };

        private struct SampleEventMsgData
        {
            public SampleMsgType msgType;
        };

        // This sample doesn't really need to support a queue of messages for action required by the 
        // backgroung thread, but use a queue anyway in case requirements change in the future.
        private Queue<SampleEventMsgData> _msgQueue = new Queue<SampleEventMsgData>();

        // The event handler should be removed when we close down.
        private bool _fAddedEventHandler = false;

        // Use a timer to avoid reacting to every event in a rapid sequence of events.
        private System.Windows.Forms.Timer _timerRefresh;

        // When the event handler decides that it's time to update the list of hyperlinks
        // in the UI, it invokes a delegate running on the main UI thread to have that 
        // thread respond to the request.
        private Win7UIAClientForm_LinkProcessor _formMainUI;
        public delegate void SampleUIEventHandlerDelegate();
        private Win7UIAClientForm_LinkProcessor.SampleUIEventHandlerDelegate _sampleUIEventHandlerDelegate;

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // SampleEventHandler() - Constructor.
        //
        // Runs on the main UI thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public SampleEventHandler(Win7UIAClientForm_LinkProcessor formMainUI, Win7UIAClientForm_LinkProcessor.SampleUIEventHandlerDelegate sampleUIEventHandlerDelegate)
        {
            _formMainUI = formMainUI;

            _sampleUIEventHandlerDelegate = sampleUIEventHandlerDelegate;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // ~SampleEventHandler() - Destructor.
        //
        // Runs on the main UI thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        ~SampleEventHandler()
        {
            CleanUp();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // Uninitialize()
        //
        // Called on main UI thread to close the background thread down.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public void Uninitialize()
        {
            // Tell the background thread to close down.
            if (_threadBackground != null)
            {
                SampleEventMsgData msgData = new SampleEventMsgData();
                msgData.msgType = SampleMsgType.msgCloseDown;
                AddMsgToQueue(msgData);
            }

            // Release all the objects created on startup now.
            CleanUp();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // AddMsgToQueue()
        //
        // Update a list of messages waiting to be processed by the background thread.
        // 
        // Run on the main UI thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        private void AddMsgToQueue(SampleEventMsgData msgData)
        {
            // Request the lock, and block until it is obtained.
            Monitor.Enter(_msgQueue);
            try
            {
                // When the lock is obtained, add an element.
                _msgQueue.Enqueue(msgData);
            }
            finally
            {
                // Ensure that the lock is released.
                Monitor.Exit(_msgQueue);
            }

            _autoEventMsg.Set();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // CleanUp()
        //
        // Runs on main UI thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        void CleanUp()
        {
            // Release all the objects that were allocated on the same thread 
            // that the CEventHandler's StartEventHandler() was called on.

            // *** Note: Do not remove the UIA event handler on this thread. 
            // The UIA event handler must be removed on the same thread as
            // that which added it.

            // In this sample, there are no objects to clean up.
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // StartEventHandler()
        //
        // Create the background thread on which the UIA event handler must run.
        //
        // This function runs on the main UI thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public void StartEventHandler()
        {
            // This sample doesn't expect to enter here with a background thread already initialized.
            if (_threadBackground != null)
            {
                return;
            }

            // The main thread will notify the background thread later when it's time to close down.
            _autoEventMsg = new AutoResetEvent(false);

            // Create the background thread, and wait until it's ready to start working.
            _autoEventInit = new AutoResetEvent(false);
            ParameterizedThreadStart paramThreadStart = new ParameterizedThreadStart(s_DoWork);

            _threadBackground = new Thread(paramThreadStart);
            _threadBackground.SetApartmentState(ApartmentState.MTA); // The event handler must run on an MTA thread.
            _threadBackground.Start(this);

            _autoEventInit.WaitOne();

            // The background thread is up and running. Have it add the UIA event handler now.
            SampleEventMsgData msgData = new SampleEventMsgData();
            msgData.msgType = SampleMsgType.msgRegisterEventHandler;
            AddMsgToQueue(msgData);
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // s_DoWork()
        //
        // Static entry point for the thread on which the event handlers will be added.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public static void s_DoWork(object data)
        {
            SampleEventHandler eventHandler = (SampleEventHandler)data;
            eventHandler.ThreadProc();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // ThreadProc()
        //
        // Entry point for the background MTA thread on which the UIA event handler will be added.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        private void ThreadProc()
        {
            // The first step in calling UIA, is getting a CUIAutomation object.
            _automation = new CUIAutomation();

            // Let the main thread know this thread is ready to start processing.
            _autoEventInit.Set();

            // fCloseDown will be set true when the thread is to close down.
            bool fCloseDown = false;

            while (!fCloseDown)
            {
                // Wait here until we're told we have some work to do.
                _autoEventMsg.WaitOne();

                while (true)
                {
                    SampleEventMsgData msgData;

                    // Note that none of the queue or message related action here is specific to UIA.
                    // Rather it is only a means for the main UI thread and the background MTA thread
                    // to communicate.

                    // Get a message from the queue of action-related messages.
                    Monitor.Enter(_msgQueue);
                    try
                    {
                        // An exception is thrown when the queue is empty.
                        msgData = _msgQueue.Dequeue();
                    }
                    catch (InvalidOperationException)
                    {
                        // InvalidOperationException is thrown if the queue is empty.
                        msgData.msgType = SampleMsgType.msgNull;

                        // No more messages in the queue.
                        break;
                    }
                    finally
                    {
                        // Ensure that the lock is released.
                        Monitor.Exit(_msgQueue);
                    }

                    if (msgData.msgType == SampleMsgType.msgRegisterEventHandler)
                    {
                        // The main thread has requested that the UIA event handler is set up now.
                        RegisterStructureChangeListener();
                    }
                    else if (msgData.msgType == SampleMsgType.msgCloseDown)
                    {
                        // The main UI thread is telling this background thread to close down.
                        fCloseDown = true;

                        break;
                    }                    
                }
            }

            // Remove the UIA event handler now if it was successfully added earlier.
            RemoveSampleEventHandler();
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // RegisterStructureChangeListener()
        //
        // Add a UIA event handler to react to structure change events sent from the browser window.
        //
        // Runs on the background thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        void RegisterStructureChangeListener()
        {
            // This sample assumes we know which window we want to gets events from.

            // *** Note: We must get a pointer to the element we're interested in, in this thread. Do 
            // not have the UI thread get the element and supply it through to the background thread.

            IntPtr hwnd = Win32.FindWindow(strBrowserWindowClass, null);
            if (hwnd != IntPtr.Zero)
            {
                _elementBrowser = _automation.ElementFromHandle(hwnd);
                if (_elementBrowser != null)
                {
                    // In general it is not the IEFrame element itself which throws the structure change 
                    // events which we will receive in the handler, but rather various decendants elements. 
                    // It is these descendants which are the "senders" in the event handler later.

                    // AddStructureChangedEventHandler() can take a cache request as other UIA methods do.
                    // So if an event handler wanted to retrieve properties from the event sender without
                    // having to incur the time cost for a cross-proc call, it would use a cache request
                    // here. (For this sample, the event handler doesn't need that.)

                    // Other types of UIA event handler can be set up with the following calls:
                    //   AddFocusChangeEventHandler()
                    //   AddAutomationEventHandler()
                    //   AddPropertyChangeEventHandler() - note that some providers might not raise all 
                    //                                     the expected propety change events.

                    _automation.AddStructureChangedEventHandler(_elementBrowser, TreeScope.TreeScope_Descendants, null, this);

                    _fAddedEventHandler = true;
                }
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // RemoveSampleEventHandler()
        //
        // Perform all cleanup of objects that we initialized on startup in the background thread.
        //
        // Runs on the background thread.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        void RemoveSampleEventHandler()
        {
            // If we successfully added an event handler earlier, remove it now. The
            // handler must be removed on the same thread on which it was added.
            if (_fAddedEventHandler)
            {
                // Depending on the timing of events generated around the time we remove 
                // the event handler, an event can arrive at the handler after a successful 
                // call to remove the event handler. So set the flag here to prevent our 
                // event handler from taking any more action if futher calls to our event 
                // handler are made.
                _fAddedEventHandler = false;

                try
                {
                    _automation.RemoveStructureChangedEventHandler(_elementBrowser, this);
                }
                catch
                {
                    // An exception can be thrown here if the browser window has already been closed.                    
                }
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // HandleStructureChangedEvent()
        //
        // Sample application's handler for UIA StructureChanged events.
        //
        // Runs on a background thread create by UIA.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public void HandleStructureChangedEvent(IUIAutomationElement sender, StructureChangeType changeType, int[] array)
        {
            // A structure changed event has been sent by the browser window element or some descendant of it.

            // Check that this event hasn't arrived around the time we're removing the event handler on shutdown.
            if (!_fAddedEventHandler)
            {
                return;
            }

            // For this sample, all the event handler needs to do is notify the main UI thread that the 
            // list of hyperlinks should be refreshed to make sure it's showing the most current list.
            
            // A shipping event handler might want to interact with the sender of the events.
            // For example if this was a Focus Changed event handler, it might get the cached
            // bounding rect from the sender to highlight where focus is now. Preferably the
            // work done is kept to a minimum in the UIA event handler itself, so the handler
            // could signal to another thread that action is required. 

            // Note that the browser window can send many Structure Changed events in rapid succession.
            // There's nothing to be gained by trying to act on every event received, so only refresh 
            // the list of hyperlinks 2 seconds after an event is received. (This delay would want to 
            // be tuned for the best user experience in a shipping app.)

            if (_timerRefresh == null)
            {
                _timerRefresh = new System.Windows.Forms.Timer();
                _timerRefresh.Tick += new EventHandler(timerRefresh_Tick);
                _timerRefresh.Interval = 2000;

                _timerRefresh.Start();
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////
        //
        // timerRefresh_Tick()
        //
        // Sample application's handler for UIA StructureChanged events.
        //
        // Runs on same background UIA thread that our event handler was called on.
        //
        /////////////////////////////////////////////////////////////////////////////////////////////////
        public void timerRefresh_Tick(object sender, EventArgs e)
        {
            // It's time to refresh the list of hyperlinks shown in the sample UI.
            _timerRefresh.Stop();
            _timerRefresh = null;

            // Now have the main thread react to the request to update the shown list of hyperlinks.
            // (This call will return immediately.)
            _formMainUI.BeginInvoke(_sampleUIEventHandlerDelegate);
        }
    }
}
